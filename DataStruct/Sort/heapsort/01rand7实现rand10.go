package heapsort

/**
 * @Description
 * @Author ZzzWw
 * @Date 2022-06-09 14:46
 **/

/*

rand M 实现 rand N 有两种情况：

一、 M>N
rand M 范围：1---M
rand N 范围：1---N
直接丢弃大于N的部分即可

比如rand 5 实现 rand 3 伪码：
rand 5范围 1，2，3，4，5
rand 3范围 1，2，3
当rand 5 产生的数字大于3的时候，直接丢弃即可：

num:=rand 5
for{
   if num>3{
   num=rand 5
    }
    return num
}


二、 M<N
关键在于公式：(rand X-1)* Y +rand Y
(rand X-1)* Y +rand Y 的范围：
1，2，3，4-------(X-1)Y+Y

同理：(rand X -1)* X+rand X的范围：
1，2，3，4-------(X-1)X+X

1.rand 7 实现 rand 10

func rand10() int {
     num:=(rand7()-1)*7+rand7() //1-49
for{
//num>10 >20 >30 都可以，只不过40丢弃的数字最少
     if num>40{
			num=(rand7()-1)*7+rand7()
		}else{
			return num%10+1
		}
	}

1,2,3,4,5,6,7,8,9,10
11----------------20               前四列都是均匀分布的
21----------------30               num%10+1 可以等概率生成1-10
31----------------40
41---------------49


rand 5 实现 rand7

func rand7() int {
	num:=(rand5()-1)*5+rand5() //1,2,3,4------25
	for{
//为什么num>21呢
      1，2，3，4，5，6，7，8，9，10
映射7：(1，2，3，4，5，6，0)，(1，2，3
      11，12，13，14，15，16，17，18，19，20
映射7：4，  5， 6， 0)， (1，2 ，3 ，4 ，5， 6
      21，22，23，24，25
映射7：0 )，后面不用了

可以看出等概率映射【0，6】的范围是【1-21】,所以选择21
当然选择7或14或21都可以，只不过选择21丢弃的数字最少，循环的次数少，减少了时间消耗。
		if num>21{
			num=(rand5()-1)*5+rand5()
		}else{
			return num%7+1
		}
	}
}

rand3构造rand18

先用rand3实现rand9 ,再用rand9实现rand18

func rand18(){

rand9:=(rand3()-1)*3+rand3()//1----9==rand9
num= (rand9()-1)*9+rand9() //1---81
for{


//这个72有什么规律可以快速知道呢：
就是18小于81的最大倍数，18*4=72<81,18*5>81
所以取72
1----18*1：num%18+1：0-17
19---18*2：num%18+1：0-17
37---18*3：num%18+1：0-17
----------
-----18*4=72 num%18+1：0-17
所以num>72,当然也可以取num>18;num>36;num>54;只是取num>72丢弃的数字最少

   if num>72{
			num=(rand9()-1)*9+rand9()
		}else{
			return num%18+1
		}
}

}

*/